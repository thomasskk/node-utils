import*as e from"htmlparser2";import t,{createReadStream as r,createWriteStream as n}from"node:fs";import s,{pipeline as o,Readable as a}from"node:stream";import c,{promisify as i}from"node:util";import f from"node:child_process";import p from"node:zlib";const u="_parent",l=e=>{const t=e.trim(),r=t.toLowerCase();return"true"===r||"false"!==r&&t},y=t=>{let r={},n="";const s=new e.Parser({onopentag:(e,t)=>{const s=(e=>{const t={};for(const r of Object.keys(e))t[r]=l(e[r]?.trim());return t})(t);n=e;const o=Object.keys(s).length>0,a=o?s:{};r[e]?(Array.isArray(r[e])||(r[e]=[r[e]]),o&&r[e].push(a)):r[e]=a,a[u]=r,r=a},ontext:e=>{if(0===Object.keys(r).length)return;if(!e.trim())return;const t=l(e),s="boolean"==typeof t?t:(e=>e.split("\n").map((e=>e.trim())).join(""))(e),o=r[u];Object.keys(o[n]).length>1&&!Array.isArray(o[n])&&(o[n]=[r]),Array.isArray(o[n])?o[n].push(s):o[n]=s},onclosetag:()=>{const e=r[u];delete r[u],r=e}},{xmlMode:!0});return s.write(t),s.end(),r},m="[object process]"===Object.prototype.toString.call("undefined"!=typeof process?process:0),h=2,g=4,d=8,b=1,w=1,A=2,k=2,S=4,j=4,B=4,O=8,x=e=>{let t=0;return t=null!==e&&"object"==typeof e?(e=>{let t=0;try{let r=e;switch(!0){case e instanceof Map:r=Object.fromEntries(e);break;case e instanceof Set:r=Array.from(e);break;case e instanceof Int8Array:return e.length*b;case e instanceof Uint8Array||e instanceof Uint8ClampedArray:return e.length*w;case e instanceof Int16Array:return e.length*A;case e instanceof Uint16Array:return e.length*k;case e instanceof Int32Array:return e.length*S;case e instanceof Uint32Array:return e.length*j;case e instanceof Float32Array:return e.length*B;case e instanceof Float64Array:return e.length*O}const n=JSON.stringify(r);t=Buffer.from(n).byteLength}catch(e){return console.error("Error detected, return -1",e),-1}return t})(e):(e=>{const t=[],r=[e];let n=0;for(;r.length;){const e=r.pop();switch(typeof e){case"boolean":n+=g;break;case"string":n+=""===(s=e)?4:Buffer.from(s).byteLength;break;case"number":n+=d;break;case"symbol":n+=(e.toString().length-8)*h;break;case"bigint":n+=Buffer.from(String(e)).byteLength;break;case"function":n+=e.toString().length;break;case"object":if(-1===t.indexOf(e)){t.push(e);for(const t in e)r.push(e[t])}}}var s;return n})(e),(e=>{let t=0;for(;e>=1e3&&++t;)e/=1e3;return`${e.toFixed(e<10&&t>0?1:0)} ${["Bytes","KB","MB","GB"][t]}`})(t)},U=i(o),v=(e,t)=>e in t,E=async e=>{const{url:r,dest:n}=e;try{const e=await fetch(r);if(!e.body)return{error:"No body in response",success:!1};const o=s.Readable.fromWeb(e.body),a=t.createWriteStream(n);return await s.promises.finished(o.pipe(a)),{success:!0}}catch(e){return{error:I(e),success:!1}}},I=e=>"object"==typeof e&&null!==e&&"message"in e&&"string"==typeof e.message?e.message:"Unknown error",L=async e=>{try{return(await t.promises.stat(e)).isDirectory()}catch(e){return!1}},M=async(e,t={})=>{const{log:r=!0}=t,n=c.promisify(f.exec)(e),s=n.child;r&&(s.stdout?.pipe(process.stdout),s.stderr?.pipe(process.stdout)),await n},_=(e,t)=>e.reduce(((e,r)=>(e[e.length-1].length===t&&e.push([]),e[e.length-1].push(r),e)),[[]]),z=async e=>{const t=[];return e.on("data",(e=>{t.push(e)})),await new Promise((t=>e.on("end",t))),Buffer.concat(t)},C=e=>{const{path:t,data:s}=e,o=p.createGzip({level:p.constants.Z_BEST_COMPRESSION}),c=void 0!==s?a.from(s):r(t);return{getStream:()=>c.pipe(o),async writeTo(e){const t=n(e);await U(c,o,t)},getBuffer:async()=>z(c.pipe(o))}},F=e=>{const{path:t,data:s}=e,o=p.createGunzip(),c=void 0!==s?a.from(s):r(t);return{getStream:()=>c.pipe(o),async writeTo(e){const t=n(e);await U(c,o,t)},getBuffer:async()=>z(c.pipe(o))}};export{_ as chunk,E as download,M as execAsync,z as getBufferFromStream,I as getErrorMessage,F as gunzip,C as gzip,L as isDir,m as isNodeEnv,x as sizeof,v as valueInObj,y as xml2js};
