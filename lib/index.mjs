import*as e from"htmlparser2";import r,{createReadStream as t,createWriteStream as n}from"node:fs";import s,{pipeline as o}from"node:stream";import c,{promisify as a}from"node:util";import i from"node:child_process";import u from"node:zlib";const f="_parent",p=e=>{const r=e.trim(),t=r.toLowerCase();return"true"===t||"false"!==t&&r},l=r=>{let t={},n="";const s=new e.Parser({onopentag:(e,r)=>{const s=(e=>{const r={};for(const t of Object.keys(e))r[t]=p(e[t]?.trim());return r})(r);n=e;const o=Object.keys(s).length>0,c=o?s:{};t[e]?(Array.isArray(t[e])||(t[e]=[t[e]]),o&&t[e].push(c)):t[e]=c,c[f]=t,t=c},ontext:e=>{if(0===Object.keys(t).length)return;if(!e.trim())return;const r=p(e),s="boolean"==typeof r?r:(e=>e.split("\n").map((e=>e.trim())).join(""))(e),o=t[f];Object.keys(o[n]).length>1&&!Array.isArray(o[n])&&(o[n]=[t]),Array.isArray(o[n])?o[n].push(s):o[n]=s},onclosetag:()=>{const e=t[f];delete t[f],t=e}},{xmlMode:!0});return s.write(r),s.end(),t},y="[object process]"===Object.prototype.toString.call("undefined"!=typeof process?process:0),h=2,m=4,g=8,b=1,d=1,A=2,k=2,w=4,j=4,O=4,S=8,B=e=>{let r=0;return r=null!==e&&"object"==typeof e?(e=>{let r=0;try{let t=e;switch(!0){case e instanceof Map:t=Object.fromEntries(e);break;case e instanceof Set:t=Array.from(e);break;case e instanceof Int8Array:return e.length*b;case e instanceof Uint8Array||e instanceof Uint8ClampedArray:return e.length*d;case e instanceof Int16Array:return e.length*A;case e instanceof Uint16Array:return e.length*k;case e instanceof Int32Array:return e.length*w;case e instanceof Uint32Array:return e.length*j;case e instanceof Float32Array:return e.length*O;case e instanceof Float64Array:return e.length*S}const n=JSON.stringify(t);r=Buffer.from(n).byteLength}catch(e){return console.error("Error detected, return -1",e),-1}return r})(e):(e=>{const r=[],t=[e];let n=0;for(;t.length;){const e=t.pop();switch(typeof e){case"boolean":n+=m;break;case"string":n+=""===(s=e)?4:Buffer.from(s).byteLength;break;case"number":n+=g;break;case"symbol":n+=(e.toString().length-8)*h;break;case"bigint":n+=Buffer.from(String(e)).byteLength;break;case"function":n+=e.toString().length;break;case"object":if(-1===r.indexOf(e)){r.push(e);for(const r in e)t.push(e[r])}}}var s;return n})(e),(e=>{let r=0;for(;e>=1e3&&++r;)e/=1e3;return`${e.toFixed(e<10&&r>0?1:0)} ${["Bytes","KB","MB","GB"][r]}`})(r)},x=a(o),U=(e,r)=>e in r,E=async e=>{const{url:t,dest:n}=e;try{const e=await fetch(t);if(!e.body)return{error:"No body in response",success:!1};const o=s.Readable.fromWeb(e.body),c=r.createWriteStream(n);return await s.promises.finished(o.pipe(c)),{success:!0}}catch(e){return{error:I(e),success:!1}}},I=e=>"object"==typeof e&&null!==e&&"message"in e&&"string"==typeof e.message?e.message:"Unknown error",L=async e=>{try{return(await r.promises.stat(e)).isDirectory()}catch(e){return!1}},M=async(e,r={})=>{const{log:t=!0}=r,n=c.promisify(i.exec)(e),s=n.child;t&&(s.stdout?.pipe(process.stdout),s.stderr?.pipe(process.stdout)),await n},_=(e,r)=>e.reduce(((e,t)=>(e[e.length-1].length===r&&e.push([]),e[e.length-1].push(t),e)),[[]]),z=async(e,r)=>{try{const s=u.createGzip({level:u.constants.Z_BEST_COMPRESSION}),o=t(e),c=n(r);return await x(o,s,c),{success:!0}}catch(e){return{error:I(e),success:!1}}},C=async(e,r)=>{try{const s=u.createGunzip(),o=t(e),c=n(r),a=o.pipe(s).pipe(c);return await new Promise((e=>a.on("finish",e))),{success:!0}}catch(e){return{error:I(e),success:!1}}};export{_ as chunk,E as download,M as execAsync,I as getErrorMessage,z as gzip,L as isDir,y as isNodeEnv,B as sizeof,C as unzip,U as valueInObj,l as xml2js};
